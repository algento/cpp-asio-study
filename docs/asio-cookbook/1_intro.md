# Introduction

Asio는 객체지향형 버클리 소켓 API이다.

## Active Socket/Passive Socket

### Active Socket

active socket은 원격 앱으로 데이터를 송/수신하거나 연결 수립하는 과정을 시작하는데 사용하는 소켓을 말한다.

### Passive Socket

passive socket 혹은 acceptor socket은 TCP 프로토콜로 원격 앱으로 들어오는 연결 수립 요청을 기다리는 소켓을 말한다.

- passive socket은 서버 프로그램이나 서버/클라이언트 역할을 모두하는 복합 프로그램에서만 사용한다.
- passive socket은 연결 수립 요청을 기다리므로 TCP에서만 사용가능하다. (UDP는 연걸 수립을 하지 않는다!)

## DNS

raw ip 주소는 기억하기 어렵다. 특히 IPv6인 경우는 더욱 어렵기 때문에 사람이 기억하기 쉽도록 DNS (Domain Name System)이 도입됐다.
DNS 이름이란 하나 또는 그 이상의 raw ip 주소에 대한 별칭 (alias)이다. 따라서 실제 네트워크 프로그램에서는 사용할 수 없고 이를 IP 주소로 변환해서 사용해야 한다. 이 과정을 DNS nam parsing이라고 한다.

asio::ip::tcp::resolver를 이용해서 종료점 (endpoint)들을 얻을 수 있다. 일반적으로 하나 이상의 IP 주소가 나온다. 클라이언트에서는 어느 종료점과 통신할 수 있는지 알 수 없기 때문에 일반적으로 원하는 응답을 들을 때까지 종료점을 돌아가면서 한번 씩 통신을 시도한다.

## Binding a socket to endpoint

생성한 소켓을 특정 종료점과 묶는 과정을 바인딩이라고 한다. 소켓이 종료점과 비인딩되면 운영체제가 네트웨크에서 해당 종료점으로 들어오는 모든 네트워크 패킷을 소켓으로 전달하며 소켓에서 나가는 데이터는 종료점의 IP 주소를 통해 네트워크로 송출된다.

클라이언트는 서버의 종료점을 알아야 하지만 자신의 종료점이 무엇인지는 중요하지 않다. 이처럼 클라이언트에서는 능동소켓을 명시적으로 종료점에 바인딩하지 않고 이 경우 운영체제는 암묵적 바인딩을 시도한다. (앞서 이야기했듯 능동 소켓은 원격 프로그램과 통신을 하며, 수용자 소켓을 연결 요청을 받는다.)
하지만 서버는 자신의 종료점을 명시적으로 수용자 소켓과 바인딩을 해야한다. 그래야 임의의 클라이언트들이 서버에 접속을 요청하고 데이터를 송/수신할 수 있다.

## Connecting a socket

TCP 소켓으로 원격 앱과 통신을 시작하려면 실제 통신에 앞서 논리적인 연결 수립 (connection establishment)을 해야한다.
연결 수립은 두 프로그램 사이에서 확인 응답 (ACK, acknowledge) 서비스 메세지 주고 받는 것을 의미한다. 이것이 성공해야만 두 소켓이 서로 논리적으로 연결되었다고 할 수 있다.

연결 수립 과정은 다음과 같다. (점대점(point-to-point) 통신 모델을 가정한다.)

1. 클라이언트는 소켓을 생성하고 connect()를 실행해 연결 수립 요청 메세지를를 서버로 전송하고 대기한다.
1. 서버는 자신이 사용할 소켓을 생성하고 대기한다. 클라이언트로부터 연셜 수립 요청 메세지를 받으면 연결이 성공했다는 사실을 알리는 메세지 (ACK)를 클라이언트로 전송한다.
1. 클라이언트는 서버로 부터 ACK를 받고 자신도 성공했다는 것을 알리기 위해 서버로 ACK 메세지를 전송한다.
1. 위의 과정을 완료하면 두 소켓 사이의 논리적 연결이 수립되었다고 간주한다.

connect 메서드는 연결하는 대상의 종료점을 인자로 받는다. 자신의 종료점이 아님에 주의해라. 자신의 종료점은 운영체제가 고른 IP 주소와 포트 번호를 사용한다. 또한 connect를 통한 연결 과정은 동기적이다. 즉, 이 메서드가 성공할 때까지 해당 스레드는 블록 상대로 있다.

DNS에 연결할 때는 DNS를 해석 (parsing)한 결과를 보고 소켓을 연결해야 한다. 그 이유는 소켓을 연결하기 위한 프로토콜을 DNS를 해석한 다음에야 알 수 있기 때문이다. 이런 작업을 알아서 처리해주는 함수가 asio::connect 함수이다. 이 함수를 소켓을 열지 않은 상태에서 소켓과 DNS 해석결과인 종료점 컨테이너를 전달하면 열결에 성공할 때까지 컨테이너 내의 종료점을 순환하며 연결을 시도한다.

## Accept connections

클라이언트에서 서버와의 논리적 연결 수립을 위해서 능동소켓을 할당하고 connect()를 호출해서 연결 명령을 실행하면 연결 수립 요청 메세지가 서보로 전송된다. 서버는 클라이언트에서 연결 수립 요청이 오기 전에 사전 작업을 진행하고 연결수립 요청 메세지가 오기를 대기한다. 이 사전 작업이 되어 있지 않다면 운영체제는 서버로 들어오는 모든 연결 수립 요청을 거절한다.
위의 사전 작업은 다음과 같다.

1. 서버는 수용자 소켓을 만들고 자신의 종료점에 바인딩한다. 이 때까지도 운영체제는 연결 수립을 거절한다.
1. 수용자 소켓을 듣기 (listen) 모드로 전환한다. 이제부터 운영체제는 연결 요청을 거절하지 않고 받아들인다.
1. 클라이언트에서 연결 요청이 도착하면 운영체제는 먼저 받아서 수용자 소켓의 대기열 (queue)에 연결 요청을 저장한다.
1. 서버에서 능동 소켓 객체를 생성한다.
1. 서버는 accept()를 호출한다. accept는 능동 소켓 객체를 인자로 받으며, 호출 시 수용자 소켓의 대기열을 검사하고 대기열 상태에 따라 다음의 2가지 방식으로 동작한다.
    1. 대기열이 비어있는 경우, 새로운 연결 요청이 들어오기 전까지 동작을 멈추고 대기한다.
    1. 대기열대기열에서 꺼내온 연결요청 처리에 성공하면 인자로 전달받은 능동소켓 객체에 클라이언트 소켓을 연결한다.
1. 이제 서버와 클라이언트는 논리적 연결 수립이 완료되었으며 통신할 수 있다.

수용자 소켓은 연결요청을 처리하는데만 사용되며, 실제 클라이언트와의 통신은 내부적으로 생성되는 능동소켓에 의해서 처리된다. 즉, 수용자 소켓은 연결요청을 처리하고 다음 연결요청을 처리하거나 대기한다. 수용자 소켓에서 연결 요청이 처리되면 운영체제가 선택한 종료점에 바인딩한 능동소켓이 생성되며 이를 클라이언트의 능동소켓과 연결한다.
UDP의 경우, 연결 수립 과정이 없으므로 별도의 수용자 소켓을 사용하지 않는다. 대신 능동소켓을 바인딩하기만 하면 된다. 바인딩된 능동소켓은  들어오는 메세지가 있는지 내부적으로 듣고 연결을 수립하며 이를 통신할 때도 사용한다.
  
## Reference

1. [boost asio network programming little book](https://nanxiao.gitbooks.io/boost-asio-network-programming-little-book)
