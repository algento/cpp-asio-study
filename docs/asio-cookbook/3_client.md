# Client Application

클라이언트는 서버와 통신하는 어플리케이션이다. 일반적으로 클라이언트는 서버에 데이터를 요청하고 서버는 그 요청을 받아 데이터를 제공하는 형태이다.
클라이언트가 서버에 자신의 선택에 의해 접근한다면 서버는 클라이언트로부터 들어오는 요청을 수동적으로 기다린다. 따라서 클라이언트는 서버가 제공하는 서비스가 필요하며 그것을 받기 위해 서버에 접속해 통신 세션을 시작해야 한다는 특징을 가진다. 클라이언트가 하는 일은 다음과 같다.

1. 요청 준비
2. 서버로 요청 전송
3. 서버에서 요청 처리 후 클라이언트로 응답 전송
4. 응답 처리

클라이언트는 프로토콜에 따라 TCP/UDP로 분류할 수 있지만, 동기 방식/비동기 방식으로 구분할 수도 있다. 동기 방식 클라이언트는 요청한 동기 연산이 끝나거나 오류가 발생할 때까지 실행 중인 스레드를 블락하는 방식이다. 비동기 방식 클라이언트는 요청한 비동기 연산을 별도의 스레드에서 실행하고 비동기 연산을 호출한 스레드는 블락하지 않는다.

동기 방식의 장점은 간단하다는 것이다. 개발하기도 디버깅하기도 쉽다. 하지만 동기 연산이 완료될 때까지 (오류 발생 포함) 호출한 스레드가 블록된다는 단점과 이미 시작한 동기 연산을 취소할 수도 없다는 단점을 가지고 있다.
비동기 방식은 비동기 연산을 호출한 스레드와 다른 스레드에서 연산이 완료되고 완료 이벤트를 호출 스레드로 콜백함수로 전달한기 때문에 프로그램 구조가 상대적으로 더 복잡하다. 따라서 이를 유지하기 위한 리소스 등으로 인해서 특수한 상황에서는 동기 방식보다 비효율적이다. 하지만 비동기 방식은 연산을 언제든 취소할 수 있으며 이는 매우 큰 유연성을 어플리케이션에 제공한다. 예를 들어 한 스레드를 사용해서 서로 다른 요청을 처리하는 것이 가능해진다.
동기 방식과 비동기 방식 중 어느 것이 효율적인지는 어떤 시스템을 사용하는지 어떤 어플리케이션인지에 따라 달라지므로 직접 측정해보는 것을 추천한다.

## Synchronous TCP Client

여기서 구현할 클라이언트는 서버 프로그램에 ascii 문자열로 표현된 요청을 보내고 서버는 해당 요청을 처리하고 응답을 보낸다.
응답도 마찬가지로 ascii로 표현된 문자열로 전송되며 연산이 성공하면 "OF<LF>", 실패하면 "ERROR<LF>"를 전송한다.

## Synchronous UDP Client

asio를 이용할 경우, 소켓 타입이 udp인 것을 빼고는 tcp와 큰 차이없다.

## Asynchronous TCP Client

비동기 클라이언트는 동기 클라이언트에 비해 프로그램 구조가 더 복잡하다. 여기서는 요청을 비동기 적으로 처리하거나 취소할 수 있는 비동기 TCP 클라이언트를 구현한다. 프로그램의 요구 사양은 다음과 같다.

- 서버에서 오는 입력을 처리하는 별도의 스레드 (ui thread)가 필요하다. 이 스레드는 눈에 띌 정도로 긴 시간 동안 멈추는 일이 없어야 한다.
- 사용자가 다양한 서버로 요청을 보낼 수 있어야 한다.
- 사용자가 요청을 보낸 후 완료되기 전에 취소할 수 있어야 한다.

비동기 단일 스레드 TCP 클라이언트능 이벤트 루프를 돌면성 요청을 처리하는 스레드가 하나이거나 다수일 수 있다. 요청이 드물고 응답의 크기가 크지 않고 연산 시간이 많이 드는 연산을 수행하지 않는다면 단일 스레드로도 충분하다. 다중 스레드로 처리할 경우, 여러 개의 스레드가 동시에 여러 요청을 처리할 수 있다. 하드웨어 적으로 지원하는 수보다 많은 스레드를 동시에 실행시키면 스레드 교환에 따른 부하로 속도가 저하될 수 있다.
